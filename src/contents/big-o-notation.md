---
path: "/big-o-notion"
date: "2019-06-10"
title: "빅오분석법(Big O Notation)이란?"
---

---

##Big O Notion 이란?
알고리즘의 성능을 평가하는 방법 중 하나로 데이터의 크기에 따라 대표 함수를 정해  
어떤 함수와 비슷한지 수학적으로 비교한다.  

##특징
1. 최악의 상황이라도 이정도의 성능은 보장할 수 있다.
2. __상수항__ 은 알고리즘 성능에 아무런 영향을 주지 않으므로 무시한다.
3. n에 데이터 크기에 영향력 없는 항들은 무시한다.
4. 최고차항이 얼마인지 에만 춧점을 맞춘다.

```
  O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(2ⁿ) < O(n!) < O(nⁿ) //오른쪽으로 갈수록 효율성이 떨어진다.
```

##설명

![ex_screenshot](https://user-images.githubusercontent.com/45478754/59185322-a8b37d00-8b5f-11e9-82d1-ec3cf030ffc0.jpg)

###-O(1)
```
  int sum = 0;  //1 번 실행
  int i; //1번 실행
  for(i=l ;i<=l00;i++){ //101번 실행 (빠져나가는 과정에서 1번 실행)
    sum = sum+l; //100번 실행
  }
```
O(203) 이지만 상수는 알고리즘 성능에 영향을 주지 않으므로 O(1)로 표기한다.  


###-O(n)
```
  for(int i=0; i<n; i++){
      //
  }
```
임의의 값 N을 입력받아 N번 실행

###-O(n^2)
```
  for(int i=0; i<n; i++){
    for(int j=0; j<n; j++){

    }
  }
```
N번을 N번 반복

###- O(logN)
처리 데이터 양이 증가할 수록 실행시간이 늘어나지만 증가 폭이 크지않다.  
일반적으로 효율성이 좋은 알고리즘이 여기에 해당한다.

###-O(NlogN)
실행시간이 O(n^2)보다 그래프로 확인하면 약간 더 증가하지만 효율이 좋은 알고리즘 중 하나다.   

###-O(n^3)
```
  for(;){
    for(;){
      for(;){

      }
    }
  }
```
세제곱 만큼이나 실행시간이 증가한다. 중첩 for문이 이에 해당한다.


###-O(2^n)
최악의 알고리즘 중 하나이다. 모든 조합과 방법을 찾을 때 사용한다.  



##정리
1. 실행하는 n을 식으로 표현
2. 최고차항만 남겨두고 아래차수와 상수는 무시한다.  


###_출처_
https://noahlogs.tistory.com/27  
https://joshuajangblog.wordpress.com/2016/09/21/time_complexity_big_o_in_easy_explanation/  
